<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><meta content="initial-scale=1" name="viewport" /><title>ROM - Overview</title><meta content="summary" name="twitter:card" /><meta content="@rom_rb" name="twitter:site" /><meta content="/3.0/learn/kafka/" name="og:url" /><meta content="ROM - Overview" name="og:title" /><meta content="http://rom-rb.org/images/logo--card.png" name="og:image" /><meta content="An open-source persistence and mapping toolkit for Ruby built for speed and simplicity." name="og:description" /><link href="/assets/stylesheets/all.css" rel="stylesheet" /><script src="/assets/javascripts/all.js"></script></head><body class="x3"><div class="sponsorship-banner">Weâ€™re taking ROM to the next level, and we need your help.<a href="https://sponsor.hanamirb.org"><span>Become a patron today</span></a></div><div class="page"><div class="grid"><header class="header"><div class="header__logo"><a href="/" class="header__logo__link">Ruby Object Mapper</a></div><div class="header__menu-toggler" id="navigation__toggler"><span class="fa fa-navicon"></span></div><div class="header__menu" id="navigation__items"><nav class="menu"><ul class="menu__items"><li class="menu__item"><a href="/learn" class="menu__item__link">Learn</a></li><li class="menu__item"><a href="/guides" class="menu__item__link">Guides</a></li><li class="menu__item"><a href="/api" class="menu__item__link">API</a></li><li class="menu__item"><a href="/blog" class="menu__item__link">Blog</a></li><li class="menu__item"><a href="/contribute" class="menu__item__link">Contribute</a></li><li class="menu__item"><a href="https://discourse.rom-rb.org" class="menu__item__link">Discuss</a></li><li class="menu__item"><a href="/status" class="menu__item__link">Status</a></li><li class="menu__item--last"><a href="https://opencollective.com/rom" class="menu__item__link">Donate</a></li></ul></nav></div></header><div class="page__sidebar"><div class="sidebar"><h2 class="sidebar__header--first">Learn</h2><ul class="sidebar__items"><li class="sidebar__item"><a href="/3.0/learn/introduction/" class="sidebar__link">Introduction</a><ul class="sidebar__sub-items"><li class="sidebar__sub-item"><a href="/3.0/learn/introduction/philosophy/" class="sidebar__sub-link">Philosophy</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/introduction/why/" class="sidebar__sub-link">Why ROM?</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/introduction/overview/" class="sidebar__sub-link">Overview</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/introduction/active-record/" class="sidebar__sub-link">Active Record and ROM</a></li></ul></li><li class="sidebar__item"><a href="/3.0/learn/getting-started/" class="sidebar__link">Getting Started</a><ul class="sidebar__sub-items"><li class="sidebar__sub-item"><a href="/3.0/learn/getting-started/setup-dsl/" class="sidebar__sub-link">Setup DSL</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/getting-started/rails-setup/" class="sidebar__sub-link">Rails Setup</a></li></ul></li><li class="sidebar__item"><a href="/3.0/learn/core/" class="sidebar__link">Core</a><ul class="sidebar__sub-items"><li class="sidebar__sub-item"><a href="/3.0/learn/core/relations/" class="sidebar__sub-link">Relations</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/core/schemas/" class="sidebar__sub-link">Schemas</a></li></ul></li><li class="sidebar__item"><a href="/3.0/learn/repositories/" class="sidebar__link">Repositories</a><ul class="sidebar__sub-items"><li class="sidebar__sub-item"><a href="/3.0/learn/repositories/quick-start/" class="sidebar__sub-link">Quick Start</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/repositories/reading-simple-objects/" class="sidebar__sub-link">Reading Simple Objects</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/repositories/reading-aggregates/" class="sidebar__sub-link">Reading Aggregates</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/repositories/changesets/" class="sidebar__sub-link">Changesets</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/repositories/composing-relations/" class="sidebar__sub-link">Composing Relations</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/repositories/custom-changesets/" class="sidebar__sub-link">Custom Changesets</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/repositories/changeset-transactions/" class="sidebar__sub-link">Changeset Transactions & Associations</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/repositories/writing-aggregates/" class="sidebar__sub-link">Writing Aggregates</a></li></ul></li><li class="sidebar__item"><a href="/3.0/learn/sql/" class="sidebar__link">SQL</a><ul class="sidebar__sub-items"><li class="sidebar__sub-item"><a href="/3.0/learn/sql/relations/" class="sidebar__sub-link">Relations</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/sql/schemas/" class="sidebar__sub-link">Schemas</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/sql/queries/" class="sidebar__sub-link">Queries</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/sql/attributes/" class="sidebar__sub-link">Attributes</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/sql/associations/" class="sidebar__sub-link">Associations</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/sql/joins/" class="sidebar__sub-link">Joins</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/sql/transactions/" class="sidebar__sub-link">Transactions</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/sql/migrations/" class="sidebar__sub-link">Migrations</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/sql/commands/" class="sidebar__sub-link">Commands</a></li></ul></li><li class="sidebar__item"><a href="/3.0/learn/kafka/" class="sidebar__link--is-active">Kafka</a></li><li class="sidebar__item"><a href="/3.0/learn/advanced/" class="sidebar__link">Advanced</a><ul class="sidebar__sub-items"><li class="sidebar__sub-item"><a href="/3.0/learn/advanced/explicit-setup/" class="sidebar__sub-link">Explicit Setup</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/advanced/combine/" class="sidebar__sub-link">Combining Relation Results</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/advanced/commands/" class="sidebar__sub-link">Standalone Commands</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/advanced/custom-commands/" class="sidebar__sub-link">Custom Commands</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/advanced/mappers/" class="sidebar__sub-link">Mappers</a></li><li class="sidebar__sub-item"><a href="/3.0/learn/advanced/how-to-build-an-adapter/" class="sidebar__sub-link">Adapters</a></li></ul></li><li class="sidebar__item"><a href="/3.0/learn/glossary/" class="sidebar__link">Glossary</a></li></ul><h4 class="sidebar__version">Previous versions: <ul id="sidebar__old-versions-nav"><li><a href="/3.0/learn">3.0</a></li><li><a href="/4.0/learn">4.0</a></li><li><a href="/5.0/learn">5.0</a></li></ul></h4></div></div><div class="page__content"><div class="content"><div class="current-version-banner"><p class="button">Version 3.0</p></div><h1>Kafka &raquo; Overview</h1><p>ROM supports <a href="http://kafka.apache.org/">Apache Kafka</a> via <a href="https://github.com/rom-rb/rom-kafka">rom-kafka</a> adapter, that is
built on top of the <a href="https://github.com/bpot/poseidon">poseidon</a> ruby driver.</p>

<blockquote>
<p>Before v0.1.0 the adapter is still in alpha. If you find any inconsistency,
please feel free to ask your questions at the <a href="https://rom-rb.zulipchat.com">ROM chatroom</a> and
report issues <a href="https://github.com/rom-rb/rom-kafka">on github</a>.</p>
</blockquote>
<h2 id="intro" class="hd"><a name="intro" class="anchor" href="#intro">            <svg aria-hidden="true" height="16" width="16" version="1.1" viewBox="0 0 16 16">
            <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
            </svg>
</a>Intro</h2>
<p>The adapter provides access to Kafka brokers in much the same way as other
adapters do for corresponding datastores with some specifics:</p>

<ul>
<li><p>By the very nature of Kafka, it allows only creating (publishing) messages,
and reading (consuming) them. No &#39;update&#39; and &#39;delete&#39; commands are available.</p></li>
<li><p>Reading messages from Kafka also differs from what you&#39;d expect from a
database. Kafka only supports reading a sequence of messages from a <em>topic</em>&#39;s
<em>partition</em>, starting from some <em>offset</em> . You can neither reorder messages or
filter them in any way. That operations are up to domain application. All you
can define is the topic (<a href="#relations">relations</a>), its <a href="#partition">partition</a>,
initial <a href="#offset">offset</a>, and <a href="#limit">limit</a> for number of messages to
output.</p></li>
</ul>
<h2 id="setup" class="hd"><a name="setup" class="anchor" href="#setup">            <svg aria-hidden="true" height="16" width="16" version="1.1" viewBox="0 0 16 16">
            <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
            </svg>
</a>Setup</h2>
<p>Set a Kafka gateway in a <a href="/3.0/learn/getting-started/setup-dsl">ROM generic way</a>. When setting a gateway
you have to specify the <code>client_id</code> and a list of Kafka brokers. Brokers can be
set in the following ways:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="c1"># by default (connects to host 'localhost', port 9092)</span>
<span class="no">ROM</span><span class="o">::</span><span class="no">Configuration</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:kafka</span><span class="p">,</span> <span class="ss">client_id: :admin</span><span class="p">)</span>

<span class="c1"># with inline address (host:port)</span>
<span class="no">ROM</span><span class="o">::</span><span class="no">Configuration</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:kafka</span><span class="p">,</span> <span class="s1">'localhost:9092'</span><span class="p">,</span> <span class="ss">client_id: :admin</span><span class="p">)</span>

<span class="c1"># ...or a list of addresses</span>
<span class="no">ROM</span><span class="o">::</span><span class="no">Configuration</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:kafka</span><span class="p">,</span> <span class="s1">'127.0.0.1:9092'</span><span class="p">,</span> <span class="s1">'127.0.0.2:9092'</span><span class="p">,</span> <span class="ss">client_id: :admin</span><span class="p">)</span>

<span class="c1"># with explicit array of `hosts` and `port`</span>
<span class="no">ROM</span><span class="o">::</span><span class="no">Configuration</span><span class="p">.</span><span class="nf">new</span> <span class="ss">:kafka</span><span class="p">,</span>
  <span class="ss">hosts:     </span><span class="p">[</span><span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="s1">'127.0.0.2'</span><span class="p">],</span>
  <span class="ss">port:      </span><span class="mi">9092</span><span class="p">,</span>
  <span class="ss">client_id: :admin</span>

<span class="c1"># or their combination (the same as '127.0.0.1:9092', '127.0.0.1:9093')</span>
<span class="no">ROM</span><span class="o">::</span><span class="no">Configuration</span><span class="p">.</span><span class="nf">new</span> <span class="ss">:kafka</span><span class="p">,</span> <span class="s1">'127.0.0.1'</span><span class="p">,</span>
  <span class="ss">hosts:     </span><span class="p">[</span><span class="s1">'127.0.0.2:9093'</span><span class="p">],</span>
  <span class="ss">port:      </span><span class="mi">9092</span><span class="p">,</span>
  <span class="ss">client_id: :admin</span>
</code></pre></div><h3 id="additional-options" class="hd"><a name="additional-options" class="anchor" href="#additional-options">            <svg aria-hidden="true" height="16" width="16" version="1.1" viewBox="0 0 16 16">
            <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
            </svg>
</a>Additional options</h3>
<p>In addition to <code>brokers</code> and <code>client_id</code> you can use the following options:</p>

<table><thead>
<tr>
<th>Attribute</th>
<th>Type</th>
<th>Default value</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td><code>:partitioner</code></td>
<td><code>Proc</code>, <code>nil</code></td>
<td><code>nil</code></td>
<td>A proc used to define partition by key.</td>
</tr>
<tr>
<td><code>:compression_codec</code></td>
<td><code>:gzip</code>, <code>:snappy</code>, <code>nil</code></td>
<td><code>nil</code></td>
<td>The type of compression to be used.</td>
</tr>
<tr>
<td><code>:metadata_refresh_interval_ms</code></td>
<td><code>Integer</code></td>
<td><code>600_000</code></td>
<td>How frequently the topic metadata should be updated (in milliseconds).</td>
</tr>
<tr>
<td><code>:max_send_retries</code></td>
<td><code>Integer</code></td>
<td><code>3</code></td>
<td>The number of times to retry sending of messages to a Kafka leader.</td>
</tr>
<tr>
<td><code>:retry_backoff_ms</code></td>
<td><code>Integer</code></td>
<td><code>100</code></td>
<td>The amount of time (in milliseconds) to wait before refreshing the metadata after we are unable to send messages.</td>
</tr>
<tr>
<td><code>:required_acks</code></td>
<td><code>Integer</code></td>
<td><code>0</code></td>
<td>The number of acks required per request.</td>
</tr>
<tr>
<td><code>:ack_timeout_ms</code></td>
<td><code>Integer</code></td>
<td><code>1_500</code></td>
<td>How long the producer waits for acks.</td>
</tr>
<tr>
<td><code>:socket_timeout_ms</code></td>
<td><code>Integer</code></td>
<td><code>10_000</code></td>
<td>How long the producer/consumer socket waits for any reply from server.</td>
</tr>
<tr>
<td><code>:min_bytes</code></td>
<td><code>Integer</code></td>
<td><code>1</code></td>
<td>The smallest amount of data the server should send (By default send data as soon as it is ready).</td>
</tr>
<tr>
<td><code>:max_bytes</code></td>
<td><code>Integer</code></td>
<td><code>1_048_576</code></td>
<td>The maximum number of bytes to fetch by consumer (1MB by default).</td>
</tr>
<tr>
<td><code>:max_wait_ms</code></td>
<td><code>Integer</code></td>
<td><code>100</code></td>
<td>How long to block until the server sends data.  This is only enforced if min_bytes is &gt; 0.</td>
</tr>
</tbody></table>
<h3 id="partitioner" class="hd"><a name="partitioner" class="anchor" href="#partitioner">            <svg aria-hidden="true" height="16" width="16" version="1.1" viewBox="0 0 16 16">
            <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
            </svg>
</a>Partitioner</h3>
<p>With the <code>:partitioner</code> option you can specify a procedure to define a partition
by key. The procedure should take 2 arguments for key and number of partitions,
and return the integer value for a partition.</p>

<p>In the following example a message is added to a corresponding partition
depending on number of letters in a key:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Configuration</span><span class="p">.</span><span class="nf">new</span> <span class="ss">:kafka</span><span class="p">,</span> <span class="s1">'127.0.0.1'</span><span class="p">,</span>
  <span class="ss">client_id:   :admin</span><span class="p">,</span>
  <span class="ss">partitioner: </span><span class="o">-&gt;</span> <span class="n">key</span><span class="p">,</span> <span class="n">number</span> <span class="p">{</span> <span class="n">key</span><span class="p">.</span><span class="nf">count</span> <span class="o">%</span> <span class="n">number</span> <span class="p">}</span>

<span class="n">insert</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="ss">:items</span><span class="p">).</span><span class="nf">create</span>

<span class="c1"># Suppose the topic "items" has 3 partitions (0 and 1).</span>
<span class="c1"># Messages "bar" and "baz" will be added to the partition 1 ("foo".count % 2 = 1).</span>
<span class="n">insert</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="ss">key: </span><span class="s2">"foo"</span><span class="p">).</span><span class="nf">call</span> <span class="s2">"bar"</span><span class="p">,</span> <span class="s2">"baz"</span>
</code></pre></div><h3 id="compression" class="hd"><a name="compression" class="anchor" href="#compression">            <svg aria-hidden="true" height="16" width="16" version="1.1" viewBox="0 0 16 16">
            <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
            </svg>
</a>Compression</h3>
<p>To use snappy compression, install the <a href="https://github.com/miyucy/snappy">snappy</a> gem, or simply add gem &#39;snappy&#39; to your project&#39;s Gemfile.</p>
<h2 id="relations" class="hd"><a name="relations" class="anchor" href="#relations">            <svg aria-hidden="true" height="16" width="16" version="1.1" viewBox="0 0 16 16">
            <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
            </svg>
</a>Relations</h2>
<p>In <code>ROM::Kafka</code> the relation describes a topic. You can read messages from a specific partition from a specified offset.
By default both the partition and initial offset are set to 0.</p>

<p>To define a Kafka relation follow <a href="/3.0/learn/core/relations">the standard way of defining relations</a> in ROM.</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">Greetings</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:kafka</span><span class="p">]</span>
  <span class="n">topic</span> <span class="ss">:greetings</span> <span class="c1"># kafka-specific alias for `relation :greetings`</span>
<span class="k">end</span>
</code></pre></div>
<p>To define relations that are exposed to you application you can define your own
methods using dataset modifiers:</p>

<ul>
<li><code>#from</code> to define a partition to read data from (0 by default).</li>
<li><code>#offset</code> to define a <em>starting</em> offset to start reading from (0 by default).</li>
<li><code>#limit</code> to define a number of messages to be fetched.</li>
<li><code>#using</code> to modify any option of the setup.</li>
</ul>

<p>The relation <code>call</code> method returns an array of tuples with 4 keys:</p>

<ul>
<li><code>value</code> for the message.</li>
<li><code>topic</code> for the current topic.</li>
<li><code>key</code> for the current key.</li>
<li><code>offset</code> for the offset of the current message.</li>
</ul>
<div class="highlight"><pre class="syntax ruby"><code><span class="c1"># After the setup</span>
<span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Configuration</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:kafka</span><span class="p">,</span> <span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="ss">client_id: :admin</span><span class="p">)</span>

<span class="n">greetings</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>

<span class="c1"># Selects all messages from the (default) partition 0</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hi!", topic: "greetings", key: nil, offset: 0 },</span>
<span class="c1">#      { value: "Hello!", topic: "greetings", key: nil, offset: 1 }</span>
<span class="c1">#    ]</span>
</code></pre></div><h3 id="partition" class="hd"><a name="partition" class="anchor" href="#partition">            <svg aria-hidden="true" height="16" width="16" version="1.1" viewBox="0 0 16 16">
            <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
            </svg>
</a>Partition</h3>
<p>By default messages are read from 0 partition. You can explicitly select the
partition to read from:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="c1"># Will read all messages from the partition 1 of the "greetings" topic</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">from</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">to_a</span>
</code></pre></div><h3 id="using-options" class="hd"><a name="using-options" class="anchor" href="#using-options">            <svg aria-hidden="true" height="16" width="16" version="1.1" viewBox="0 0 16 16">
            <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
            </svg>
</a>Using options</h3>
<p>Kafka allows reading messages from given offset. Messages are fetched by
chunks - you can set a maximum and minimum length (in bytes), as well as the
wait time for the server to responce.</p>

<p>This options can be set for a gateway during the <a href="#setup">setup phase</a>:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Configuration</span><span class="p">.</span><span class="nf">new</span> <span class="ss">:kafka</span><span class="p">,</span>
  <span class="ss">client_id: :admin</span><span class="p">,</span>
  <span class="ss">min_bytes: </span><span class="mi">1_024</span><span class="p">,</span>  <span class="c1"># ignore data less then 1Kb</span>
  <span class="ss">max_bytes: </span><span class="mi">10_240</span><span class="p">,</span> <span class="c1"># read nor more than 10Kb at once</span>
  <span class="ss">max_wait_ms: </span><span class="mi">100</span>   <span class="c1"># wait for responce no longer than 100ms</span>
</code></pre></div>
<p>or you can update them with <code>using</code> method:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="c1"># read all messages whatever length they have, and wait for the request up to second</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">from</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nf">using</span><span class="p">(</span><span class="ss">min_bytes: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">max_wait_ms: </span><span class="mi">1_000</span><span class="p">).</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
</code></pre></div><h3 id="offset" class="hd"><a name="offset" class="anchor" href="#offset">            <svg aria-hidden="true" height="16" width="16" version="1.1" viewBox="0 0 16 16">
            <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
            </svg>
</a>Offset</h3>
<p>When Kafka reads messages from topic/partition, it stops at some offset. This
can be an offset of the last message (at the time of reading).</p>

<p>If in some period of time you&#39;ll make another call, it start reading messages
from the next offset (only new ones).</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="n">greetings</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hi",    topic: "greetings", key: nil, offset: 0 },</span>
<span class="c1">#      { value: "Hello", topic: "greetings", key: nil, offset: 1 }</span>
<span class="c1">#    ]</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [] (because all messages has bean read diring the first call)</span>
<span class="nb">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hola", topic: "greetings", key: nil, offset: 2 }</span>
<span class="c1">#    ]</span>
<span class="c1"># (only messages being added after the previous call)</span>
</code></pre></div>
<p>If you need to restart reading from a specific offset, you can do it by setting
<code>offset</code> explicitly:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">).</span><span class="nf">offset</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">call</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hello", topic: "greetings", key: nil, offset: 1 },</span>
<span class="c1">#    ]</span>
</code></pre></div>
<p>You can use info from the last extracted tuple to define an offset, from which
to start the next time.</p>
<h3 id="limit" class="hd"><a name="limit" class="anchor" href="#limit">            <svg aria-hidden="true" height="16" width="16" version="1.1" viewBox="0 0 16 16">
            <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
            </svg>
</a>Limit</h3>
<p>You can define a maximum number of messages to return, using the <code>limit</code> method:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="n">greetings</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">offset</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hello", topic: "greetings", key: nil, offset: 1 },</span>
<span class="c1">#      { value: "Hola",  topic: "greetings", key: nil, offset: 2 }</span>
<span class="c1">#    ]</span>
</code></pre></div>
<p>But be careful. Actual size of data being read is defined by <code>:max_bytes</code>
settings, not the offset.</p>

<p>For example, when you set <code>offset(2)</code>, the relation can actually fetch the chunk
of 5 messages (and move the next offset correspodingly). If you continue
reading, you&#39;ll miss 3 messages. That&#39;s why it is <strong>strongly recommended</strong> to
set <code>offset</code> explicitly after using of <code>limit</code> modifier.</p>

<p>This is unsafe (can cause missing messages):</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="n">greetings</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hi",    topic: "greetings", key: nil, offset: 0 },</span>
<span class="c1">#    ]</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; []</span>
</code></pre></div>
<p>while this is pretty safe:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="n">greetings</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hi",    topic: "greetings", key: nil, offset: 0 },</span>
<span class="c1">#    ]</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">offset</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hello", topic: "greetings", key: nil, offset: 1 },</span>
<span class="c1">#      { value: "Hola",  topic: "greetings", key: nil, offset: 2 }</span>
<span class="c1">#    ]</span>
</code></pre></div>
<p>Also notice, that every time you use modifier, the new connection is
re-established. That&#39;s why the <strong>rule of thumb</strong> is either not using modifiers
at all, or set the offset explicitly for every call.</p>
<h2 id="commands" class="hd"><a name="commands" class="anchor" href="#commands">            <svg aria-hidden="true" height="16" width="16" version="1.1" viewBox="0 0 16 16">
            <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
            </svg>
</a>Commands</h2>
<p>Kafka supports the <code>Create</code> <a href="/3.0/learn/advanced/commands">command only</a>. You can only add
immutable messages to the log, but not to change or delete them.</p>

<p><code>ROM::Kafka</code> provides two helpers for command: <code>#where</code> and <code>#using</code>.</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">Greet</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Commands</span><span class="o">::</span><span class="no">Create</span><span class="p">[</span><span class="ss">:kafka</span><span class="p">]</span>
  <span class="n">relation</span> <span class="ss">:greetings</span>
  <span class="n">register_as</span> <span class="ss">:greet</span>

  <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="k">super</span> <span class="n">where</span><span class="p">(</span><span class="ss">key: </span><span class="s2">"foo"</span><span class="p">).</span><span class="nf">using</span><span class="p">(</span><span class="ss">socket_timeout_ms: </span><span class="mi">10</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Here <code>where</code> modifier requires only one value for a <code>:key</code>. The <code>using</code> modifier accepts any value you&#39;ll get, but will ignore unused ones. You&#39;re recommended to use only <a href="#additional-options">those keys</a> that are defined for the producer:</p>

<ul>
<li>partitioner</li>
<li>compression_codec</li>
<li>metadata<em>refresh</em>interval_ms</li>
<li>max<em>send</em>retries</li>
<li>retry<em>backoff</em>ms</li>
<li>required_acks</li>
<li>ack<em>timeout</em>ms</li>
<li>socket<em>timeout</em>ms</li>
</ul>

<p>In case of success the command returns an array of messages added to Kafka:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="c1"># After the setup</span>
<span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Configuration</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:kafka</span><span class="p">,</span> <span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="ss">client_id: :admin</span><span class="p">)</span>
<span class="n">greet</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">).</span><span class="nf">greet</span>

<span class="n">greet</span><span class="p">.</span><span class="nf">call</span> <span class="s2">"Hi, Joe"</span><span class="p">,</span> <span class="s2">"How're you?"</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hi, Joe",     topic: "greetings", key: 0 },</span>
<span class="c1">#      { value: "How're you?", topic: "greetings", key: 0 }</span>
<span class="c1">#    ]</span>
</code></pre></div>
<p>The producer and consumer connections to Kafka brokers are separated. A command
doesn&#39;t read messages being written, and knows nothing about partitions and
offsets that where assigned by the server. You have to read them explicitly if
you need.</p>
<h2 id="mappers" class="hd"><a name="mappers" class="anchor" href="#mappers">            <svg aria-hidden="true" height="16" width="16" version="1.1" viewBox="0 0 16 16">
            <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
            </svg>
</a>Mappers</h2>
<p>Mappers can be applied to relations and commands in a
<a href="/3.0/learn/advanced/mappers">standard ROM way</a>.</p>
</div><section class="feedback"><div class="inline-buttons"><a href="https://github.com/rom-rb/rom-rb.org/blob/main/source/3.0/learn/kafka/index.html.md" class="button">Edit on GitHub</a><a href="https://github.com/rom-rb/rom-rb.org/issues/new?labels=feedback&amp;assignees=solnic&amp;title=Feedback%20on%20ROM%20-%20Overview" class="button">Provide feedback!</a></div></section></div></div></div><div class="footer"><div class="grid"><div class="footer__fine-print"><div class="footer__fine-print__copyright"><small>&copy; 2014-2025 Ruby Object Mapper. Design by <a href="https://github.com/angeloashmore">@angeloashmore</a>. Logo by <a href="https://github.com/kapowaz">@kapowaz</a>.</small></div><div class="footer__fine-print__social"><a href="https://github.com/rom-rb/rom" class="footer__fine-print__social__icon"><span class="fa fa-github-alt"></span></a><a href="https://twitter.com/rom_rb" class="footer__fine-print__social__icon--last"><span class="fa fa-twitter"></span></a></div></div></div></div></body></html>
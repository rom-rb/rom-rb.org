<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><meta content="initial-scale=1" name="viewport" /><title>ROM - Blog</title><link href="/assets/stylesheets/all.css" rel="stylesheet" /><script src="/assets/javascripts/all.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-2573270-5', 'auto');
ga('send', 'pageview');</script></head><body class="blog blog_index"><div class="page"><div class="grid"><header class="header"><div class="header__logo"><a href="/" class="header__logo__link">Ruby Object Mapper</a></div><div class="header__menu-toggler" id="navigation__toggler"><span class="fa fa-navicon"></span></div><div class="header__menu" id="navigation__items"><nav class="menu"><ul class="menu__items"><li class="menu__item"><a href="/3.0/learn" class="menu__item__link">Learn</a></li><li class="menu__item"><a href="/3.0/guides" class="menu__item__link">Guides</a></li><li class="menu__item"><a href="/api" class="menu__item__link">API</a></li><li class="menu__item"><a href="/blog" class="menu__item__link--is-active">Blog</a></li><li class="menu__item"><a href="/contribute" class="menu__item__link">Contribute</a></li><li class="menu__item"><a href="https://discourse.rom-rb.org" class="menu__item__link">Discuss</a></li><li class="menu__item"><a href="/status" class="menu__item__link">Status</a></li><li class="menu__item--last"><a href="https://opencollective.com/rom" class="menu__item__link">Donate</a></li></ul></nav></div></header><div class="page__sidebar"><div class="sidebar"><h2 class="sidebar__header--first">Blog</h2><h3 class="sidebar__header">Latest Posts</h3><ul class="sidebar__items"><li class="sidebar__item"><a href="/blog/rom-repository-1-1-0-released/" class="sidebar__link">rom-repository 1.1.0 released</a></li><li class="sidebar__item"><a href="/blog/rom-3-0-released/" class="sidebar__link">ROM 3.0 Released</a></li><li class="sidebar__item"><a href="/blog/rom-2-0-0-released/" class="sidebar__link">ROM 2.0.0 Released</a></li><li class="sidebar__item"><a href="/blog/rom-1-0-0-released/" class="sidebar__link">ROM 1.0.0 Released</a></li><li class="sidebar__item"><a href="/blog/rom-1-0-0-rc-released/" class="sidebar__link">ROM 1.0.0 RC Released</a></li></ul><h3 class="sidebar__header">Browse Tags</h3><ul class="sidebar__items"><li class="sidebar__item"><a href="/blog/tags/release" class="sidebar__link">release</a></li><li class="sidebar__item"><a href="/blog/tags/announcement" class="sidebar__link">announcement</a></li><li class="sidebar__item"><a href="/blog/tags/oss" class="sidebar__link">oss</a></li><li class="sidebar__item"><a href="/blog/tags/support" class="sidebar__link">support</a></li><li class="sidebar__item"><a href="/blog/tags/repository" class="sidebar__link">repository</a></li></ul><h3 class="sidebar__header">Subscribe</h3><p><a href="#" class="button--secondary"><span class="fa fa-rss"></span> RSS</a></p></div></div><div class="page__content"><div class="content"><article class="article"><h1 class="article__title"><a href="/blog/rom-repository-1-1-0-released/" class="article__title__link">rom-repository 1.1.0 released</a></h1><div class="article__metadata">Posted by <a href="https://twitter.com/_solnic_">Piotr Solnica</a> on February 16, 2017 under <ul class="article__tags"><li class="article__tag"><a href="/blog/tags/release">release</a></li><li class="article__tag"><a href="/blog/tags/announcement">announcement</a></li><li class="article__tag"><a href="/blog/tags/repository">repository</a></li></ul></div><p>Today we&#39;ve released a new version of rom-repository which ships with new features and a couple of bug fixes. This release focused on improving auto-mapping capabilities and making it more flexible when you want to use custom mappers.</p>

<h2>Adjusting relation nodes when loading aggregates</h2>

<p>It&#39;s now possible to adjust individual relation nodes when you&#39;re loading aggregates or composing relations manually. This feature allows you to apply additional restrictions, or use custom views, or even set custom mappers on-the-fly.</p>

<p>Let&#39;s say we want to load users with their priority tasks:</p>
<pre class="syntax ruby"><code><span class="n">aggregate</span><span class="p">(</span><span class="ss">:tasks</span><span class="p">).</span>
  <span class="nf">node</span><span class="p">(</span><span class="ss">:tasks</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">tasks</span><span class="o">|</span> <span class="n">tasks</span><span class="p">.</span><span class="nf">where</span> <span class="p">{</span> <span class="n">priority</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">}</span>
</code></pre>
<p>This also works with deeply nested nodes:</p>
<pre class="syntax ruby"><code><span class="n">aggregate</span><span class="p">(</span><span class="ss">orders: :lines</span><span class="p">).</span>
  <span class="nf">node</span><span class="p">(</span><span class="ss">orders: :lines</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">lines</span><span class="o">|</span> <span class="n">lines</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="n">line_ids</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
<h2>Disabling auto-mapping to structs</h2>

<p>By default all repositories map plain hashes to <code>ROM::Struct</code> objects, you can now disable this feature. This is useful in situations like mapping to JSON where intermediate objects are simply not needed, or when you want to use custom mappers that require hashes rather than structs.</p>

<p>You can disable mapping to structs using a repo class option:</p>
<pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">UserRepo</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="p">[</span><span class="ss">:users</span><span class="p">]</span>
  <span class="n">auto_struct</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">user_repo</span> <span class="o">=</span> <span class="no">UserRepo</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">rom</span><span class="p">)</span>
<span class="n">user_repo</span><span class="p">.</span><span class="nf">users</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># [{:id=&gt;1, :name=&gt;"Jane"}]</span>
</code></pre>
<p>or when instantiating a repo object:</p>
<pre class="syntax ruby"><code><span class="n">user_repo</span> <span class="o">=</span> <span class="no">UserRepo</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">rom</span><span class="p">,</span> <span class="ss">auto_struct: </span><span class="kp">false</span><span class="p">)</span>
</code></pre>
<p>or at run-time per individual relation:</p>
<pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">UserRepo</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="p">[</span><span class="ss">:users</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">user_hashes</span>
    <span class="n">users</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="ss">auto_struct: </span><span class="kp">false</span><span class="p">).</span><span class="nf">to_a</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">user_repo</span> <span class="o">=</span> <span class="no">UserRepo</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">rom</span><span class="p">)</span>
<span class="n">user_repo</span><span class="p">.</span><span class="nf">user_hashes</span>
<span class="c1"># [{:id=&gt;1, :name=&gt;"Jane"}]</span>
</code></pre>
<h2>Improved support for wrapping</h2>

<p>Just like <code>combine</code>, <code>wrap</code> now accepts association names. This simplifies loading nested data structures via joins. Here&#39;s a simple example:</p>
<pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">Tasks</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="n">schema</span><span class="p">(</span><span class="ss">infer: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">associations</span> <span class="k">do</span>
      <span class="n">belongs_to</span> <span class="ss">:user</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">TaskRepo</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="p">[</span><span class="ss">:tasks</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">with_user</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">tasks</span><span class="p">.</span><span class="nf">wrap</span><span class="p">(</span><span class="ss">:user</span><span class="p">).</span><span class="nf">by_pk</span><span class="p">(</span><span class="nb">id</span><span class="p">).</span><span class="nf">one</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">task_repo</span> <span class="o">=</span> <span class="no">TaskRepo</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">rom</span><span class="p">)</span>

<span class="n">task_repo</span><span class="p">.</span><span class="nf">with_user</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
<span class="c1"># #&lt;ROM::Struct[Task] id=1 user_id=1 title="A task" user=#&lt;ROM::Struct[User] id=1 name="Jane"&gt;&gt;</span>
</code></pre>
<h2>Using custom mappers along with auto-mapping</h2>

<p>You can now use <code>auto_map</code> option in <code>map_with</code> method which will apply auto-mapping before applying your own mappers. This is useful in cases where you want to use custom mappers and you want auto-mapping to handle complex structural transformations like merging multiple data sets into nested structures (which is what happens when you compose relations using <code>aggregate</code> or <code>combine</code>).</p>

<p>To enable auto-mapping with custom mappers, simply pass <code>auto_map: true</code> option, this way you don&#39;t have to worry about handling aggregates manually, as your mappers will be applied to already transformed data:</p>
<pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">UserRepo</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="p">[</span><span class="ss">:users</span><span class="p">]</span>
  <span class="n">relations</span> <span class="ss">:tasks</span>

  <span class="k">def</span> <span class="nf">custom_mapping</span>
    <span class="n">aggregate</span><span class="p">(</span><span class="ss">:tasks</span><span class="p">).</span>
      <span class="nf">map_with</span><span class="p">(</span><span class="ss">:my_custom_mapper</span><span class="p">,</span> <span class="ss">auto_map: </span><span class="kp">true</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<h2>Release Details</h2>

<p>This is a backward compatible upgrade, for more information check out the <a href="https://github.com/rom-rb/rom-repository/blob/master/CHANGELOG.md#v110-2017-02-16">CHANGELOG</a>. If you found any issues, or have trouble upgrading, please <a href="https://github.com/rom-rb/rom-repository">report it</a>.</p>
<hr /></article><article class="article"><h1 class="article__title"><a href="/blog/rom-3-0-released/" class="article__title__link">ROM 3.0 Released</a></h1><div class="article__metadata">Posted by <a href="https://twitter.com/_solnic_">Piotr Solnica</a> on January 30, 2017 under <ul class="article__tags"><li class="article__tag"><a href="/blog/tags/release">release</a></li><li class="article__tag"><a href="/blog/tags/announcement">announcement</a></li></ul></div><p>We&#39;re happy to announce the release of rom 3.0.0, a big release which comes with the first stable versions of rom-sql 1.0.0 and rom-repository 1.0.0. Changes and improvements in rom core gem focused mostly on extending functionality of relation Schema API and Command API, as well as removing all deprecated core APIs. The biggest highlight are new features in rom-sql and rom-repository.</p>

<h2>Extended Schemas</h2>

<p>Starting from rom 3.0.0 <strong>all relations, regardless of the adapter, have schemas</strong>. It means that Schema is now a 1st class API available in all adapters.</p>

<p>Schemas now use adapter-specific attribute types, which allowed us to implement all kinds of new features in rom-sql that make building complex queries much simpler. We also improved schema inference and added support for more PostgreSQL types like <code>enum</code>, <code>point</code> or <code>inet</code>. Furthermore, it&#39;s now possible to use inference along with explicit attribute definitions, which is useful in cases where inferrer doesn&#39;t support some custom column type, or when you simply want to customize your schema.</p>

<h3>Advanced projections</h3>

<p>Relation schemas are <strong>always available</strong>, they keep track of the current attributes that relation tuples will include. This is a huge improvement, since previously schemas were only the representation of canonical relations (defined by your actual database schema). Projections go through schemas, and they adjust their attributes automatically. This gives us complete information about data that any relation can return.</p>

<p>In rom-sql schema attributes are extended with SQL-specific features, which allows queries like this:</p>
<pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="n">schema</span><span class="p">(</span><span class="ss">infer: </span><span class="kp">true</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">duplicated_emails</span>
    <span class="nb">select</span> <span class="p">{</span> <span class="p">[</span><span class="n">email</span><span class="p">,</span> <span class="n">int</span><span class="o">::</span><span class="n">count</span><span class="p">(</span><span class="nb">id</span><span class="p">).</span><span class="nf">as</span><span class="p">(</span><span class="ss">:count</span><span class="p">)]</span> <span class="p">}.</span>
      <span class="nf">group</span><span class="p">(</span><span class="ss">:email</span><span class="p">).</span>
      <span class="nf">order</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="c1"># SELECT "email", COUNT("id") AS "count"</span>
  <span class="c1">#  FROM "users"</span>
  <span class="c1">#  GROUP BY "email"</span>
  <span class="c1">#  ORDER BY "email"</span>
<span class="k">end</span>
</code></pre>
<p>You can use both blocks or refer to attributes directly through <code>Relation#[]</code> method which returns schema attributes identified by their canonical names:</p>
<pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="n">schema</span><span class="p">(</span><span class="ss">infer: </span><span class="kp">true</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">duplicated_emails</span>
    <span class="nb">select</span><span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="ss">:email</span><span class="p">],</span> <span class="nb">self</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">func</span> <span class="p">{</span> <span class="n">int</span><span class="o">::</span><span class="n">count</span><span class="p">(</span><span class="nb">id</span><span class="p">).</span><span class="nf">as</span><span class="p">(</span><span class="ss">:count</span><span class="p">)</span> <span class="p">}).</span>
      <span class="nf">group</span><span class="p">(</span><span class="ss">:email</span><span class="p">).</span>
      <span class="nf">order</span><span class="p">(</span><span class="ss">:email</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="c1"># SELECT "email", COUNT("id") AS "count"</span>
  <span class="c1">#   FROM "users"</span>
  <span class="c1">#   GROUP BY "email"</span>
  <span class="c1">#   ORDER BY "email"</span>
<span class="k">end</span>
</code></pre>
<p>Resulting relation views include complete information about their current schema:</p>
<pre class="syntax ruby"><code><span class="n">users</span><span class="p">.</span><span class="nf">duplicated_emails</span><span class="p">.</span><span class="nf">schema</span><span class="p">.</span><span class="nf">attributes</span>
<span class="c1"># [</span>
<span class="c1">#   #&lt;ROM::SQL::Attribute[NilClass | String] name=:email source=ROM::Relation::Name(users)&gt;,</span>
<span class="c1">#   #&lt;ROM::SQL::Function[Integer] func=#&lt;Sequel::SQL::Function @name=&gt;"COUNT", @args=&gt;[#&lt;ROM::SQL::Attribute[Integer] primary_key=true name=:id source=ROM::Relation::Name(users)&gt;], @opts=&gt;{}&gt; alias=:count&gt;</span>
<span class="c1"># ]</span>
</code></pre>
<p>This plays a major role in automatic mapping in repositories, as they can define structs with all attribute type information provided by relations.</p>

<h3>Support for SQL functions</h3>

<p>The <code>count</code> function we used in the previous example probably caught your attention—this is a new feature which allows you to use any SQL function with arbitrary arguments, including relation attributes, or <strong>anything</strong> that can be dumped into a valid SQL. The syntax is always:</p>
<pre class="syntax ruby"><code><span class="n">type_annotation</span><span class="o">::</span><span class="n">function_name</span><span class="p">(</span><span class="o">*</span><span class="n">arguments</span><span class="p">)</span>
</code></pre>
<p>It returns a <code>ROM::SQL::Function</code> object which works like any other schema attribute, and you can qualify it or provide an alias, or use a boolean expression with various operators. Functions work with <code>select</code>, <code>order</code> and <code>where</code>. The only difference is that <code>select</code> requires a type annotation, and the other methods don&#39;t.</p>

<p>Here&#39;s another example:</p>
<pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="n">schema</span><span class="p">(</span><span class="ss">infer: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">associations</span> <span class="k">do</span>
      <span class="n">has_many</span> <span class="ss">:tasks</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">busy_people</span>
    <span class="nb">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="n">tasks</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">func</span> <span class="p">{</span> <span class="n">int</span><span class="o">::</span><span class="n">count</span><span class="p">(</span><span class="nb">id</span><span class="p">).</span><span class="nf">as</span><span class="p">(</span><span class="ss">:task_count</span><span class="p">)</span> <span class="p">}).</span>
      <span class="nf">left_join</span><span class="p">(</span><span class="n">tasks</span><span class="p">).</span>
      <span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span>
      <span class="nf">having</span> <span class="p">{</span> <span class="n">count</span><span class="p">(</span><span class="nb">id</span><span class="p">.</span><span class="nf">qualified</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">}</span>
  <span class="k">end</span>
  <span class="c1"># SELECT "users"."id", "users"."name", COUNT("tasks"."id") AS "task_count"</span>
  <span class="c1">#   FROM "users"</span>
  <span class="c1">#   LEFT JOIN "tasks" ON ("users"."id" = "tasks"."user_id")</span>
  <span class="c1">#   GROUP BY "users"."id"</span>
  <span class="c1">#   HAVING (count("users"."id") &gt; 1) ORDER BY "users"."id"</span>
<span class="k">end</span>
</code></pre>
<p>Maybe you noticed that we passed <code>tasks</code> relation object to <code>left_join</code>—this is another new feature.</p>

<h3>Improved joins</h3>

<p>You can now pass relation objects to <code>join</code>, <code>left_join</code> and <code>right_join</code>, and, assuming you configured associations, your relation will do the work for you to join the correct table with join conditions already set. Furthermore, it will be automatically qualified. Here&#39;s what it means:</p>
<pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">Tasks</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="n">schema</span><span class="p">(</span><span class="ss">infer: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">associations</span> <span class="k">do</span>
      <span class="n">belongs_to</span> <span class="ss">:user</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">with_user</span>
    <span class="c1"># "join(:users, user_id: :id).qualified" becomes:</span>
    <span class="n">join</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>There&#39;s also a new method to simplify finding all associated tuples through associations, called <code>Relation#assoc</code>, it uses configured associations to prepare a joined relation for you. Let&#39;s say we want to find all user priority tasks:</p>
<pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="n">schema</span><span class="p">(</span><span class="ss">infer: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">associations</span> <span class="k">do</span>
      <span class="n">has_many</span> <span class="ss">:tasks</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">priority_tasks</span><span class="p">(</span><span class="n">user_ids</span><span class="p">)</span>
    <span class="n">assoc</span><span class="p">(</span><span class="ss">:tasks</span><span class="p">).</span>
      <span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:title</span><span class="p">,</span> <span class="nb">self</span><span class="p">[</span><span class="ss">:name</span><span class="p">].</span><span class="nf">qualified</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:user</span><span class="p">))</span>
      <span class="n">where</span><span class="p">(</span><span class="ss">priority: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">user_id: </span><span class="n">user_ids</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">priority_tasks</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1"># SELECT "tasks"."id", "tasks"."user_id", "tasks"."title", "users"."name" AS "user"</span>
<span class="c1">#   FROM "tasks"</span>
<span class="c1">#   INNER JOIN "users" ON ("users"."id" = "tasks"."user_id")</span>
<span class="c1">#   WHERE ("priority" = 1) AND ("user_id" IN(1, 2, 3))</span>
<span class="c1">#   ORDER BY "tasks"."id"</span>
</code></pre>
<h3>Custom association views</h3>

<p>Another interesting feature is the ability to <strong>extend</strong> default association relations with a custom view. This is useful in cases where you would like to add more attributes to the resulting relation, change order etc.</p>

<p>Let&#39;s say we have users with accounts, and would like to include <code>position</code> from the join table and order accounts by that column:</p>
<pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="n">schema</span><span class="p">(</span><span class="ss">infer: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">associations</span> <span class="k">do</span>
      <span class="n">has_many</span> <span class="ss">:accounts</span><span class="p">,</span> <span class="ss">through: :users_accounts</span><span class="p">,</span> <span class="ss">view: :ordered</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Accounts</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="n">schema</span><span class="p">(</span><span class="ss">infer: </span><span class="kp">true</span><span class="p">)</span>

  <span class="n">view</span><span class="p">(</span><span class="ss">:ordered</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">schema</span> <span class="k">do</span>
      <span class="n">append</span><span class="p">(</span><span class="n">relations</span><span class="p">[</span><span class="ss">:users_accounts</span><span class="p">][</span><span class="ss">:position</span><span class="p">])</span>
    <span class="k">end</span>

    <span class="n">relation</span> <span class="k">do</span>
      <span class="n">order</span><span class="p">(</span><span class="ss">:position</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>We use View DSL in this case, as it provides schema information up-front, before a relation is even initialized. It&#39;s one of the core features in rom that allows defining composable relations. Associations are based on this feature, but you can use it without associations too.</p>

<h3>Bi-directional coercions</h3>

<p>In the first version of Schema API, canonical attribute types were used by commands exclusively. Starting with rom 3.0.0 you can also define <code>read</code> attributes, which will be used by relations when they read their tuples.</p>

<p>Let&#39;s say we have address JSONB column, and we want a custom address object back that uses JSONB attributes:</p>
<pre class="syntax ruby"><code><span class="no">Address</span> <span class="o">=</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:country</span><span class="p">,</span> <span class="ss">:city</span><span class="p">,</span> <span class="ss">:street</span><span class="p">,</span> <span class="ss">:zipcode</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:sql</span><span class="p">]</span>
  <span class="no">AddressType</span> <span class="o">=</span> <span class="no">Types</span><span class="o">.</span><span class="no">Constructor</span><span class="p">(</span><span class="no">Address</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span> <span class="no">Address</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">schema</span><span class="p">(</span><span class="ss">infer: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">attribute</span> <span class="ss">:address</span><span class="p">,</span> <span class="no">Types</span><span class="o">::</span><span class="no">PG</span><span class="o">::</span><span class="no">JSONB</span><span class="p">,</span> <span class="ss">read: </span><span class="no">AddressType</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">users</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:address</span><span class="p">).</span><span class="nf">to_a</span>
<span class="c1"># [{:address=&gt;#&lt;struct Address country="Poland", city="Krakow", street="Street 1"}]</span>
</code></pre>
<p>For now this is very explicit, in the near future we&#39;ll add various convention-based improvements, so that specifying <code>read</code> types is more concise.</p>

<h2>Improved repositories</h2>

<p>We added support for transactions, custom commands in changesets, run-time changeset mapping with custom blocks, associating data via changesets, asking for custom objects when committing a changeset... check out <a href="http://rom-rb.org/learn/repositories/changesets/">updated docs</a> to learn more, and here are some of the highlights.</p>

<h3>Comitting changesets</h3>

<p>Changesets are now standalone objects, with a new <code>Changeset#commit</code> method which allows you to store them conveniently in your database.</p>

<p>Here&#39;s a simple example of a changeset which saves a new user:</p>
<pre class="syntax ruby"><code><span class="c1"># assuming we have a repo like that:</span>
<span class="k">class</span> <span class="nc">UserRepo</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="p">[</span><span class="ss">:users</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">user_repo</span><span class="p">.</span><span class="nf">changeset</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"Jane"</span><span class="p">,</span> <span class="ss">email: </span><span class="s2">"jane@doe.org"</span><span class="p">).</span><span class="nf">commit</span>
<span class="c1"># =&gt; {:id=&gt;1, :name=&gt;"Jane", :email=&gt;"jane@doe.org"}</span>
</code></pre>
<h3>Committing changesets via repositories</h3>

<p>Changesets simply return whatever your database returned, but you can commit them via repositories that will convert raw data to rom structs:</p>
<pre class="syntax ruby"><code><span class="c1"># assuming we have a repo like that:</span>
<span class="k">class</span> <span class="nc">UserRepo</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="p">[</span><span class="ss">:users</span><span class="p">]</span>
  <span class="n">command</span> <span class="ss">:create</span>
<span class="k">end</span>

<span class="n">new_user</span> <span class="o">=</span> <span class="n">user_repo</span><span class="p">.</span><span class="nf">changeset</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"Jane"</span><span class="p">,</span> <span class="ss">email: </span><span class="s2">"jane@doe.org"</span><span class="p">)</span>

<span class="n">user_repo</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">new_user</span><span class="p">)</span>
<span class="c1"># =&gt; #&lt;ROM::Struct[User] id=1 name="Jane" email="jane@doe.org"&gt;</span>
</code></pre>
<h3>Powerful data transformations</h3>

<p>Changeset now support custom data transformations, with many builtin functions provided by <a href="https://github.com/solnic/transproc">transproc</a> gem. You can define your custom changeset classes and specify how data must be transformed before we can pass it to the underlying database command:</p>
<pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">NewUser</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Changeset</span><span class="o">::</span><span class="no">Create</span><span class="p">[</span><span class="ss">:users</span><span class="p">]</span>
  <span class="n">map</span> <span class="k">do</span>
    <span class="n">unwrap</span> <span class="ss">:address</span><span class="p">,</span> <span class="ss">prefix: </span><span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">new_user</span> <span class="o">=</span> <span class="n">user_repo</span><span class="p">.</span><span class="nf">changeset</span><span class="p">(</span><span class="no">NewUser</span><span class="p">).</span><span class="nf">data</span><span class="p">(</span>
  <span class="ss">name: </span><span class="s2">"Jane"</span><span class="p">,</span>
  <span class="ss">address: </span><span class="p">{</span>
    <span class="ss">city: </span><span class="s2">"Krakow"</span><span class="p">,</span> <span class="ss">country: </span><span class="s2">"Poland"</span><span class="p">,</span> <span class="ss">street: </span><span class="s2">"Street 1"</span><span class="p">,</span> <span class="ss">zipcode: </span><span class="s2">"1234"</span>
  <span class="p">}</span>
<span class="p">)</span>

<span class="n">new_user</span><span class="p">.</span><span class="nf">commit</span>
<span class="c1"># =&gt; {:id=&gt;1, :name=&gt;"Jane", address_city: "Krakow", address_country: "Poland", address_street: "Street 1", address_zipcode: "1234"}</span>
</code></pre>
<p>You can also pass an argument to <code>.map</code> and in that case you can use arbitrary code to perform a transformation. Check out <a href="http://rom-rb.org/learn/repositories/custom-changesets/">docs</a> to learn more.</p>

<h2>Support for nested aggregates</h2>

<p>If you specified your associations in relations, you can use a simplified interface for fetching aggregates through repositories. For example if you have users with tasks, and tasks have tags, and you want to load a user aggregate with more levels of nesting, you can now do this:</p>
<pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">UserRepo</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Repository</span><span class="p">[</span><span class="ss">:users</span><span class="p">]</span>
  <span class="n">relations</span> <span class="ss">:tasks</span><span class="p">,</span> <span class="ss">:tags</span>
<span class="k">end</span>

<span class="n">user_repo</span><span class="p">.</span><span class="nf">aggregate</span><span class="p">(</span><span class="ss">tasks: :tags</span><span class="p">)</span>
</code></pre>
<p>Check out <a href="http://www.rubydoc.info/gems/rom-repository/ROM/Repository/Root#aggregate-instance_method">Repository#aggregate</a> API docs for more information.</p>

<h2>Detailed release information</h2>

<p>As part of this release following gems have been published:</p>

<ul>
<li>rom 3.0.0 <a href="https://github.com/rom-rb/rom/blob/master/CHANGELOG.md#v300-2017-01-29">CHANGELOG</a></li>
<li>rom-sql 1.0.0 <a href="https://github.com/rom-rb/rom-sql/blob/master/CHANGELOG.md#v100-2017-01-29">CHANGELOG</a></li>
<li>rom-repository 1.0.0 <a href="https://github.com/rom-rb/rom-repository/blob/master/CHANGELOG.md#v100-2017-01-29">CHANGELOG</a></li>
<li>rom-rails 0.9.0 <a href="https://github.com/rom-rb/rom-rails/blob/master/CHANGELOG.md#v090--2017-01-30">CHANGELOG</a></li>
</ul>

<p>Please check out <a href="http://rom-rb.org">rom-rb.org</a> as it was updated with more documentation!</p>

<h2>Upgrading</h2>

<p>Please do read <a href="https://github.com/rom-rb/rom-sql/wiki/Upgrading-from-0.9.x-to-1.0.0">rom-sql 1.0.0 upgrade guide</a> as it includes useful information. Making the transition should not be difficult, many applications (including big ones), have been already upgraded during beta/RC testing, and it was a smooth process.</p>

<p>If you have problems with the upgrade, please report an issue or ask for help on <a href="https://discourse.rom-rb.org">the discussion forum</a>.</p>

<h2>Thank you!</h2>

<p>This is a long post, and it barely covers ~20% of what was improved or added, it was a huge effort to get here and I would like to thank all of the contributors, for their PRs, reported issues, and testing beta/rc releases early!</p>

<p>Special thanks go to (in no particular order):</p>

<ul>
<li><a href="https://github.com/flash-gordon">Nikita Shilnikov</a>, for his fantastic work on schema inferrers, helping <em>a lot</em> with rom-support removal by putting together <a href="https://github.com/dry-rb/dry-core">dry-core</a> and porting <strong>all rom gems</strong> to use dry-initializer</li>
<li><a href="https://github.com/Kukunin">Sergey Kukunin</a> for his help with <a href="https://github.com/solnic/transproc/blob/master/CHANGELOG.md#v100-2017-01-29">transproc 1.0.0</a> (yes, we released that too!) and helping with rom-repository mapping pipeline</li>
<li><a href="https://github.com/nepalez/">Andrew Kozin</a> for his work on <a href="https://github.com/dry-rb/dry-initializer">dry-initializer</a> which now plays major role in <strong>many</strong> core objects in rom projects and allowed us to get rid of rom-support</li>
</ul>

<h2>What happens next?</h2>

<p>We have big plans for future releases, but hopefully we&#39;ll manage to provide more frequent, incremental improvements now that rom-sql and rom-repository are stable. More details will be revealed soon, stay tuned!</p>

<p>I hope you&#39;ll find this release useful, if you have problems or any kind of feedback, please report issues or just <a href="https://gitter.im/rom-rb/chat">talk to us</a>.</p>

<p>If you happen to attend <a href="http://rubyconf.org.au">RubyConf AU</a> next week, be sure to say hi! :)</p>
<hr /></article><ul class="inline-buttons inline-buttons--centered"><li class="inline-buttons__button"><a href="/blog/page/2/" class="button"><span class="fa fa-arrow-left"></span></a></li><li class="inline-buttons__spacer inline-buttons__spacer--wide"><p><strong>1 of 7</strong></p></li><li class="inline-buttons__button inline-buttons__button"><span class="button--disabled"><span class="fa fa-arrow-right"></span></span></li></ul></div></div></div></div><div class="footer"><div class="grid"><div class="footer__content"><h3 class="footer__header">Sponsors</h3><p>We are looking for sustainable sponsorship. If your company is relying
on rom-rb or simply want to see rom-rb evolve faster to meet your requirements,
please consider backing the project through <a href="https://opencollective.com/rom">our campaign on
opencollective.com/rom</a>.</p>
</div><div class="footer__fine-print"><div class="footer__fine-print__copyright"><small>&copy; 2014-2017 Ruby Object Mapper. Design by <a href="https://github.com/angeloashmore">@angeloashmore</a>. Logo by <a href="https://github.com/kapowaz">@kapowaz</a>.</small></div><div class="footer__fine-print__social"><a href="https://github.com/rom-rb/rom" class="footer__fine-print__social__icon"><span class="fa fa-github-alt"></span></a><a href="https://twitter.com/rom_rb" class="footer__fine-print__social__icon--last"><span class="fa fa-twitter"></span></a></div></div></div></div></body></html>